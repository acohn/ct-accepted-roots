//go:generate go run generate.go -log_list_urls https://www.gstatic.com/ct/log_list/all_logs_list.json,https://ct.grahamedgecombe.com/logs.json
// +build ignore
package main

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"flag"
	"github.com/acohn/ct-accepted-roots/httpclient"
	"github.com/acohn/ct-accepted-roots/loglist/schema"
	"github.com/acohn/ct-accepted-roots/sthutil"
	"github.com/google/certificate-transparency-go/client"
	"github.com/google/certificate-transparency-go/jsonclient"
	"github.com/google/certificate-transparency-go/logid"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"sync"
	"text/template"
	"time"
)

var logListUrls = flag.String("log_list_urls", "https://ct.grahamedgecombe.com/logs.json,https://www.gstatic.com/ct/log_list/all_logs_list.json", "Comma-separated list of log URLs")

func main() {
	flag.Parse()
	httpCl, err := httpclient.Build()
	if err != nil {
		log.Fatal("Could not build HTTP client")
	}

	//Grab each log list
	knownLogs := make(map[logid.LogID]schema.Log)
	logListUrls := strings.Split(*logListUrls, ",")

	for _, listUrl := range logListUrls {
		logList, err := fetchAndParseLogList(listUrl, httpCl)
		if err != nil {
			log.Fatal(err)
		}
		for _, log := range logList.Logs {
			if !strings.HasPrefix(log.Url, "http") {
				log.Url = "https://" + log.Url
			}
			logID := logid.FromPubKeyB64OrDie(log.Key)
			knownLogs[logID] = log
		}
	}

	//attempt to connect to each one
	workingLogChan := make(chan logid.LogID, len(knownLogs))
	wg := new(sync.WaitGroup)
	for logID, log := range knownLogs {
		wg.Add(1)
		go testLog(log, logID, workingLogChan, wg, httpCl)
	}

	go func() {
		wg.Wait()
		close(workingLogChan)
	}()

	workingLogs := []schema.Log{}

	for logID := range workingLogChan {
		workingLogs = append(workingLogs, knownLogs[logID])
	}

	//for the ones that succeed, write to the all_logs.json file
	newJson, err := json.MarshalIndent(schema.LogList{Logs: workingLogs}, "", "    ")
	if err != nil {
		log.Fatal(err)

	}
	err = ioutil.WriteFile("all_logs.json", newJson, 0777)
	if err != nil {
		log.Fatal(err)
	}

	outputGoFile(workingLogs, logListUrls, "log_list.go")
	if err != nil {
		log.Fatal(err)
	}

}

func outputGoFile(logs []schema.Log, urls []string, outputFile string) error {

	type allLogsGoTemplate struct {
		Logs      []schema.Log
		URLs      []string
		Timestamp string
	}

	tmplText := `// Code generated by generate.go using go generate. DO NOT EDIT.
// Generated at
//  {{ .Timestamp }}
// using data from
// {{ .URLs }}

package main

import "github.com/acohn/ct-accepted-roots/loglist/schema"

var Logs = []schema.Log{
{{ range .Logs }}	{Key: "{{ .Key }}", Description: "{{ .Description }}", Url: "{{ .Url }}", MaximumMergeDelay: {{ .MaximumMergeDelay }}},
{{ end }}}
`

	allLogsGo := &allLogsGoTemplate{logs, urls, time.Now().UTC().Format("RFC3339")}
	file, err := os.Create(outputFile)
	if file != nil {
		defer file.Close()
	}
	if err != nil {
		return err
	}

	tmpl, err := template.New("log_list.go").Parse(tmplText)
	if err != nil {
		return err
	}
	err = tmpl.Execute(file, allLogsGo)
	return err
}

func fetchAndParseLogList(url string, hc *http.Client) (*schema.LogList, error) {

	resp, err := hc.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	listJSON, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	logList := new(schema.LogList)
	err = json.Unmarshal(listJSON, logList)
	if err != nil {
		log.Fatal(err)
	}
	return logList, nil

}

func testLog(ctLog schema.Log, logID logid.LogID, workingLogChan chan logid.LogID, wg *sync.WaitGroup, hc *http.Client) {
	defer wg.Done()
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) //Only give a log fifteen seconds to get back to us
	defer cancel()

	logKey, err := base64.StdEncoding.DecodeString(ctLog.Key)
	if err != nil {
		log.Printf("Failed to decode log key for log %v - this should not happen", ctLog.Url)
		return
	}
	client, err := client.New(ctLog.Url, hc, jsonclient.Options{PublicKeyDER: logKey})
	if err != nil {
		log.Printf("Could not create a new log client for log %v", ctLog.Url)
		return
	}
	sth, err := client.GetSTH(ctx)
	if err != nil {
		//assume the log is dead
		log.Printf("Error fetching STH from log %v: %v", ctLog.Url, err)
		return
	}
	sthTimestamp := sthutil.SthTimestampToTime(sth.Timestamp)
	if sthTimestamp.After(time.Now()) {
		log.Printf("STH from log %v is in the future by %v!", ctLog.Url, sthTimestamp.Sub(time.Now()))
		return
	}
	if sthTimestamp.Before(time.Now().Add(time.Duration(ctLog.MaximumMergeDelay) * time.Second * -1)) {
		log.Printf("Latest STH from log %v (%v) blows the MMD!", ctLog.Url, sthTimestamp)
		return
	}
	roots, err := client.GetAcceptedRoots(ctx)
	if err != nil {
		//assume the log is dead
		log.Printf("Error fetching accepted certs from log %v: %v", ctLog.Url, err)
		return
	}
	if len(roots) == 0 {
		log.Printf("Log %v does not accept from any roots!", ctLog.Url)
		return
	}

	workingLogChan <- logID
	return
}
