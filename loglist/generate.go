//go:generate go run generate.go -timeout 3
// +build ignore
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"flag"
	"github.com/acohn/ct-accepted-roots/httpclient"
	"github.com/acohn/ct-accepted-roots/loglist/schema"
	"github.com/acohn/ct-accepted-roots/sthutil"
	"github.com/google/certificate-transparency-go/client"
	"github.com/google/certificate-transparency-go/jsonclient"
	"go/format"
	"golang.org/x/net/context/ctxhttp"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
	"sync"
	"text/template"
	"time"
)

var logListUrls = flag.String("log_list_urls", "https://ct.grahamedgecombe.com/logs.json,https://www.gstatic.com/ct/log_list/all_logs_list.json", "Comma-separated list of log URLs")
var timeout = flag.Int("timeout", 15, "Timeout for all HTTP responses")

func main() {
	flag.Parse()
	httpCl, err := httpclient.Build()
	if err != nil {
		log.Fatal("Could not build HTTP client")
	}

	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(*timeout)*time.Second)
	defer cancel()

	//Grab each log list
	knownLogs := make(map[schema.LogID]schema.Log)
	logListUrls := strings.Split(*logListUrls, ",")

	for _, listUrl := range logListUrls {
		logList, err := fetchAndParseLogList(ctx, listUrl, httpCl)
		if err != nil {
			log.Fatal(err)
		}
		for _, log := range logList.Logs {
			if !strings.HasPrefix(log.Url, "http") {
				log.Url = "https://" + log.Url //Edgecombe's list has http://; Google's doesn't.
			}
			knownLogs[log.LogID()] = log
		}
	}

	//attempt to connect to each one
	workingLogChan := make(chan schema.LogID, len(knownLogs))
	wg := new(sync.WaitGroup)
	for _, log := range knownLogs {
		wg.Add(1)
		go testLog(ctx, log, workingLogChan, wg, httpCl)
	}

	go func() {
		wg.Wait()
		close(workingLogChan)
	}()

	working := new(schema.LogList)

	for logID := range workingLogChan {
		working.Logs = append(working.Logs, knownLogs[logID])
	}

	//Sort the working logs by LogID, so we don't rearrange logs based on response time and make diffs evil.
	working.Sort()

	//for the ones that succeed, write to the all_logs.json file
	newJson, err := json.MarshalIndent(working, "", "    ")
	if err != nil {
		log.Fatal(err)
	}
	err = ioutil.WriteFile("all_logs.json", newJson, 0777)
	if err != nil {
		log.Fatal(err)
	}

	outputGoFile(working.Logs, logListUrls, "log_list.go")
	if err != nil {
		log.Fatal(err)
	}

}

func outputGoFile(logs []schema.Log, urls []string, outputFile string) error {

	type allLogsGoTemplate struct {
		Logs      []schema.Log
		URLs      []string
		Timestamp string
	}

	tmplText := `// Code generated by generate.go using go generate. DO NOT EDIT.
// Generated at
//  {{ .Timestamp }}
// using data from{{ range .URLs }}
//  {{ . }}{{  end }}

package main

import "github.com/acohn/ct-accepted-roots/loglist/schema"

var Logs = schema.LogList{Logs: []schema.Log{
{{ range .Logs }}{
Key: "{{ .Key }}",
Description: "{{ .Description }}", // {{.LogIDString}}
Url: "{{ .Url }}",
MaximumMergeDelay: {{ .MaximumMergeDelay }},
},
{{ end }}}}
`

	allLogsGo := &allLogsGoTemplate{logs, urls, time.Now().UTC().Format(time.RFC1123)}

	buf := new(bytes.Buffer)

	tmpl, err := template.New("log_list.go").Parse(tmplText)
	if err != nil {
		return err
	}
	err = tmpl.Execute(buf, allLogsGo)
	if err != nil {
		return err
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(outputFile, formatted, 0644)
	return err
}

func fetchAndParseLogList(ctx context.Context, url string, hc *http.Client) (*schema.LogList, error) {

	resp, err := ctxhttp.Get(ctx, hc, url)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	listJSON, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	logList := new(schema.LogList)
	err = json.Unmarshal(listJSON, logList)
	if err != nil {
		log.Fatal(err)
	}
	return logList, nil

}

func testLog(ctx context.Context, ctLog schema.Log, workingLogChan chan schema.LogID, wg *sync.WaitGroup, hc *http.Client) {
	defer wg.Done()

	logKey, err := ctLog.KeyDER()
	if err != nil {
		log.Printf("Failed to decode log key for log %v - this should not happen", ctLog.Url)
		return
	}
	client, err := client.New(ctLog.Url, hc, jsonclient.Options{PublicKeyDER: logKey})
	if err != nil {
		log.Printf("Could not create a new log client for log %v", ctLog.Url)
		return
	}
	sth, err := client.GetSTH(ctx)
	if err != nil {
		//assume the log is dead
		log.Printf("Error fetching STH from log %v: %v", ctLog.Url, err)
		return
	}
	sthTimestamp := sthutil.SthTimestampToTime(sth.Timestamp)
	if sthTimestamp.After(time.Now()) {
		log.Printf("STH from log %v is in the future by %v!", ctLog.Url, sthTimestamp.Sub(time.Now()))
		return
	}
	if sthTimestamp.Before(time.Now().Add(time.Duration(ctLog.MaximumMergeDelay) * time.Second * -1)) {
		log.Printf("Latest STH from log %v (%v) blows the MMD!", ctLog.Url, sthTimestamp)
		return
	}
	roots, err := client.GetAcceptedRoots(ctx)
	if err != nil {
		//assume the log is dead
		log.Printf("Error fetching accepted certs from log %v: %v", ctLog.Url, err)
		return
	}
	if len(roots) == 0 {
		log.Printf("Log %v does not accept from any roots!", ctLog.Url)
		return
	}

	workingLogChan <- ctLog.LogID()
	return
}
